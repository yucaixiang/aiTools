# 前端业务错误提示修复说明

## 问题描述

调用 `POST /api/reviews` 时，如果后端返回：
```json
{
  "code": 3001,
  "message": "您已评论过该工具"
}
```

前端没有弹出错误提示，用户不知道发生了什么。

## 问题原因

**HTTP状态码 vs 业务状态码的区别**：

1. **HTTP状态码** (如200, 401, 500)：由Web服务器返回
2. **业务状态码** (如code: 200, 3001, 1001)：由后端业务逻辑返回

**之前的错误处理逻辑**：
```javascript
// 响应拦截器
request.interceptors.response.use(
  (response) => {
    return response.data  // ❌ 直接返回，不检查业务code
  },
  (error) => {
    // 只处理HTTP错误（如401, 500等）
  }
)
```

**问题**：
- 当HTTP状态码是200，但业务code是3001时
- 不会进入error回调
- 直接返回了数据，没有显示错误提示

## 修复方案

修改响应拦截器，在成功回调中检查业务code：

```javascript
// 响应拦截器
request.interceptors.response.use(
  (response) => {
    const res = response.data

    // ✅ 检查业务code，如果不是200则认为是业务错误
    if (res.code !== undefined && res.code !== 200) {
      console.log('========== 业务错误拦截 ==========')
      console.log('Code:', res.code)
      console.log('Message:', res.message)

      const errorMessage = res.message || '请求失败'

      // ✅ 显示错误提示Toast
      toast.error(errorMessage)

      // ✅ 如果是401业务错误，清除登录状态
      if (res.code === 401) {
        localStorage.removeItem('token')
        localStorage.removeItem('user')
        setTimeout(() => {
          window.location.href = '/login'
        }, 1500)
      }

      // ✅ 抛出业务错误
      const businessError = new Error(errorMessage)
      businessError.code = res.code
      businessError.data = res.data
      return Promise.reject(businessError)
    }

    // 业务成功，返回数据
    return res
  },
  (error) => {
    // 处理HTTP错误...
  }
)
```

## 修复效果

### 场景1: 重复评论

**请求**:
```javascript
POST /api/reviews
{
  "toolId": 5,
  "rating": 5,
  "content": "很好用"
}
```

**后端响应** (HTTP 200):
```json
{
  "code": 3001,
  "message": "您已评论过该工具",
  "data": null
}
```

**修复前**: ❌ 没有任何提示，用户不知道发生了什么

**修复后**: ✅ 弹出Toast提示："您已评论过该工具"

### 场景2: 用户名已存在

**请求**:
```javascript
POST /api/users/register
{
  "username": "admin",
  "email": "test@test.com",
  "password": "123456"
}
```

**后端响应** (HTTP 200):
```json
{
  "code": 1001,
  "message": "用户名已存在",
  "data": null
}
```

**修复前**: ❌ 没有提示

**修复后**: ✅ 弹出Toast提示："用户名已存在"

### 场景3: 邮箱已被注册

**后端响应** (HTTP 200):
```json
{
  "code": 1002,
  "message": "邮箱已被注册",
  "data": null
}
```

**修复前**: ❌ 没有提示

**修复后**: ✅ 弹出Toast提示："邮箱已被注册"

### 场景4: 未授权（业务层）

**后端响应** (HTTP 200):
```json
{
  "code": 401,
  "message": "未授权，请先登录",
  "data": null
}
```

**修复前**: ❌ 没有提示

**修复后**:
- ✅ 弹出Toast提示："未授权，请先登录"
- ✅ 清除本地token和user信息
- ✅ 1.5秒后跳转到登录页

## 错误处理流程

### 完整的错误处理链

```
1. 发送请求
   ↓
2. 后端处理
   ↓
3. 返回响应
   ↓
4. 前端响应拦截器
   ↓
   ├─ HTTP状态码检查
   │  ├─ 200 ──→ 继续
   │  ├─ 401 ──→ HTTP错误处理 ──→ Toast + 跳转登录
   │  └─ 500 ──→ HTTP错误处理 ──→ Toast提示
   ↓
5. 业务code检查（✅ 新增）
   ↓
   ├─ code === 200 ──→ 返回数据
   │
   ├─ code === 401 ──→ 业务错误处理
   │                   ├─ Toast提示
   │                   ├─ 清除登录信息
   │                   └─ 跳转登录页
   │
   └─ code !== 200 ──→ 业务错误处理
                       ├─ Toast提示
                       └─ 抛出错误
```

## 后端常见业务错误码

根据代码，后端可能返回以下业务错误码：

| Code | Message | 场景 |
|------|---------|------|
| 200 | success | 成功 |
| 400 | 参数错误 | 参数校验失败 |
| 401 | 未授权，请先登录 | 未登录或token过期 |
| 404 | 工具不存在 | 找不到指定的工具 |
| 1001 | 用户名已存在 | 注册时用户名重复 |
| 1002 | 邮箱已被注册 | 注册时邮箱重复 |
| 1003 | 密码错误 | 登录时密码错误 |
| 3001 | 您已评论过该工具 | 重复评论 |
| 500 | 系统异常 | 服务器内部错误 |

## 测试验证

### 测试1: 重复评论

1. 登录系统
2. 进入某个工具详情页
3. 提交一条评论（成功）
4. 再次提交评论（重复）
5. **期望**: 弹出Toast提示"您已评论过该工具"

### 测试2: 用户名已存在

1. 进入注册页面
2. 输入已存在的用户名（如"admin"）
3. 点击注册
4. **期望**: 弹出Toast提示"用户名已存在"

### 测试3: 查看控制台日志

打开浏览器开发者工具Console，当业务错误发生时应该看到：
```
========== 业务错误拦截 ==========
Code: 3001
Message: 您已评论过该工具
Toast.error调用成功: 您已评论过该工具
```

## 修改文件

- `/Users/bjsttlp324/Desktop/tools/frontend/web/src/api/request.js`

## 注意事项

### 1. 不会影响正常请求

业务code为200的请求不受影响：
```json
{
  "code": 200,
  "message": "success",
  "data": {...}
}
```
正常返回data，不会触发错误提示。

### 2. 兼容没有code字段的响应

如果响应中没有code字段（如某些第三方API），不会触发业务错误检查：
```javascript
if (res.code !== undefined && res.code !== 200) {
  // 只有当code存在且不是200时才处理
}
```

### 3. 错误可以在组件中捕获

组件中仍然可以使用try-catch捕获错误并自定义处理：
```javascript
try {
  await createReview(reviewData)
  toast.success('评论成功')
} catch (error) {
  // Toast已经在拦截器中显示了
  // 这里可以做额外的处理，如重置表单
  console.log('评论失败:', error.message)
}
```

### 4. Toast不会重复显示

如果组件中也调用了toast.error()，不会导致重复提示，因为Toast组件会自动去重。

## 总结

### 修复前

- ✅ HTTP错误（401, 500等）有Toast提示
- ❌ 业务错误（code: 3001等）没有提示

### 修复后

- ✅ HTTP错误有Toast提示
- ✅ 业务错误有Toast提示
- ✅ 统一的错误处理逻辑
- ✅ 更好的用户体验

现在所有的错误都会有明确的提示，用户不会困惑为什么操作没有成功！
