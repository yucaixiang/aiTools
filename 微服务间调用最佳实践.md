# 微服务间调用最佳实践

**日期**: 2025-12-10
**问题**: `getUserFavorites`方法中的RestTemplate调用异常

---

## 问题分析

### 当前问题

**文件**: `user-service/src/main/java/com/toolrecommend/user/service/impl/FavoriteServiceImpl.java:91`

```java
ToolVO tool = restTemplate.getForObject(
    "http://tool-service/tools/" + toolId,  // ❌ 错误: 无法解析域名
    ToolVO.class
);
```

### 错误原因

1. **服务发现缺失**: `http://tool-service` 是服务名,需要Eureka/Nacos等服务发现组件
2. **当前架构**: 项目使用Gateway做路由,没有服务注册中心
3. **URL错误**: 应该调用实际的HTTP地址,不是服务名

---

## 解决方案对比

### 方案1: RestTemplate + 直连(不推荐)

**优点**:
- 简单快速
- 不需要额外依赖

**缺点**:
- 硬编码地址,难以维护
- 没有负载均衡
- 没有服务降级
- 代码冗余

```java
// ❌ 不推荐
String url = "http://localhost:8081/api/tools/" + toolId;
ToolVO tool = restTemplate.getForObject(url, ToolVO.class);
```

### 方案2: RestTemplate + Gateway转发(临时方案)

**优点**:
- 统一通过Gateway
- 利用现有架构
- 可以复用Gateway的认证/限流等功能

**缺点**:
- 性能损耗(多一跳)
- Gateway压力大
- 不是最佳实践

```java
// ⚠️ 可以用但不是最佳
String url = "http://localhost:8090/api/tools/" + toolId;
ToolVO tool = restTemplate.getForObject(url, ToolVO.class);
```

### 方案3: OpenFeign(✅ 推荐)

**优点**:
- 声明式调用,代码简洁
- 自动负载均衡
- 支持服务降级(Sentinel/Resilience4j)
- Spring Cloud标准方案
- 易于测试和维护

**缺点**:
- 需要添加依赖
- 需要一定学习成本

---

## ✅ 推荐方案: 使用OpenFeign

### 步骤1: 添加依赖

**文件**: `user-service/pom.xml`

```xml
<dependencies>
    <!-- Spring Cloud OpenFeign -->
    <dependency>
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-starter-openfeign</artifactId>
    </dependency>

    <!-- 负载均衡(可选,如果需要多实例) -->
    <dependency>
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-starter-loadbalancer</artifactId>
    </dependency>
</dependencies>

<!-- Spring Cloud版本管理 -->
<dependencyManagement>
    <dependencies>
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-dependencies</artifactId>
            <version>2023.0.0</version>
            <type>pom</type>
            <scope>import</scope>
        </dependency>
    </dependencies>
</dependencyManagement>
```

### 步骤2: 启用Feign

**文件**: `UserServiceApplication.java`

```java
@SpringBootApplication
@EnableFeignClients  // ✅ 添加这个注解
public class UserServiceApplication {
    public static void main(String[] args) {
        SpringApplication.run(UserServiceApplication.class, args);
    }
}
```

### 步骤3: 创建Feign Client

**文件**: `user-service/src/main/java/com/toolrecommend/user/client/ToolServiceClient.java`

```java
package com.toolrecommend.user.client;

import com.toolrecommend.common.result.Result;
import com.toolrecommend.common.vo.ToolVO;
import org.springframework.cloud.openfeign.FeignClient;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestParam;

import java.util.List;

/**
 * Tool服务Feign客户端
 *
 * @author Tool Recommend Team
 */
@FeignClient(
    name = "tool-service",
    url = "${service.tool-service.url:http://localhost:8081}",
    fallbackFactory = ToolServiceClientFallbackFactory.class
)
public interface ToolServiceClient {

    /**
     * 根据ID获取工具详情
     */
    @GetMapping("/api/tools/{id}")
    Result<ToolVO> getToolById(@PathVariable("id") Long id);

    /**
     * 批量获取工具详情(推荐)
     */
    @GetMapping("/api/tools/batch")
    Result<List<ToolVO>> getToolsByIds(@RequestParam("ids") List<Long> ids);
}
```

### 步骤4: 创建降级工厂(可选但推荐)

**文件**: `user-service/src/main/java/com/toolrecommend/user/client/ToolServiceClientFallbackFactory.java`

```java
package com.toolrecommend.user.client;

import com.toolrecommend.common.result.Result;
import com.toolrecommend.common.vo.ToolVO;
import lombok.extern.slf4j.Slf4j;
import org.springframework.cloud.openfeign.FallbackFactory;
import org.springframework.stereotype.Component;

import java.util.Collections;
import java.util.List;

/**
 * Tool服务降级工厂
 *
 * @author Tool Recommend Team
 */
@Slf4j
@Component
public class ToolServiceClientFallbackFactory implements FallbackFactory<ToolServiceClient> {

    @Override
    public ToolServiceClient create(Throwable cause) {
        return new ToolServiceClient() {
            @Override
            public Result<ToolVO> getToolById(Long id) {
                log.error("调用tool-service失败,工具ID: {}, 原因: {}", id, cause.getMessage());
                // 返回降级数据
                return Result.error(500, "获取工具详情失败");
            }

            @Override
            public Result<List<ToolVO>> getToolsByIds(List<Long> ids) {
                log.error("批量调用tool-service失败,工具IDs: {}, 原因: {}", ids, cause.getMessage());
                // 返回空列表而不是报错
                return Result.success(Collections.emptyList());
            }
        };
    }
}
```

### 步骤5: 配置文件

**文件**: `user-service/src/main/resources/application.yml`

```yaml
# 服务地址配置
service:
  tool-service:
    url: http://localhost:8081

# Feign配置
feign:
  client:
    config:
      default:
        # 连接超时时间
        connectTimeout: 5000
        # 读取超时时间
        readTimeout: 10000
        # 日志级别
        loggerLevel: BASIC
  # 启用降级
  circuitbreaker:
    enabled: true
```

### 步骤6: 修改FavoriteServiceImpl

**文件**: `user-service/src/main/java/com/toolrecommend/user/service/impl/FavoriteServiceImpl.java`

```java
package com.toolrecommend.user.service.impl;

import com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;
import com.baomidou.mybatisplus.extension.plugins.pagination.Page;
import com.toolrecommend.common.entity.Favorite;
import com.toolrecommend.common.result.PageResult;
import com.toolrecommend.common.result.Result;
import com.toolrecommend.common.vo.ToolVO;
import com.toolrecommend.user.client.ToolServiceClient;
import com.toolrecommend.user.mapper.FavoriteMapper;
import com.toolrecommend.user.service.FavoriteService;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;

import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;

/**
 * 收藏服务实现类
 *
 * @author Tool Recommend Team
 */
@Slf4j
@Service
@RequiredArgsConstructor
public class FavoriteServiceImpl implements FavoriteService {

    private final FavoriteMapper favoriteMapper;
    private final ToolServiceClient toolServiceClient;  // ✅ 使用Feign Client

    @Override
    public PageResult<ToolVO> getUserFavorites(Long userId, Long current, Long size) {
        // 分页查询用户的收藏
        Page<Favorite> page = new Page<>(current, size);
        LambdaQueryWrapper<Favorite> wrapper = new LambdaQueryWrapper<>();
        wrapper.eq(Favorite::getUserId, userId)
               .orderByDesc(Favorite::getCreatedAt);

        Page<Favorite> favoritePage = favoriteMapper.selectPage(page, wrapper);

        // 获取工具ID列表
        List<Long> toolIds = favoritePage.getRecords().stream()
                .map(Favorite::getToolId)
                .collect(Collectors.toList());

        // ✅ 使用Feign批量调用tool-service (推荐)
        List<ToolVO> tools = new ArrayList<>();
        if (!toolIds.isEmpty()) {
            try {
                Result<List<ToolVO>> result = toolServiceClient.getToolsByIds(toolIds);
                if (result != null && result.isSuccess()) {
                    tools = result.getData();
                }
            } catch (Exception e) {
                log.error("批量获取工具详情失败", e);
                // 降级: 返回空列表或部分数据
            }
        }

        PageResult<ToolVO> result = new PageResult<>();
        result.setRecords(tools);
        result.setTotal(favoritePage.getTotal());
        result.setCurrent(favoritePage.getCurrent());
        result.setSize(favoritePage.getSize());
        result.setPages(favoritePage.getPages());

        return result;
    }

    // 其他方法保持不变...
}
```

---

## 临时快速修复(不使用Feign)

如果暂时不想引入Feign,可以这样快速修复:

### 修改application.yml

```yaml
# 服务地址配置
service:
  tool-service:
    base-url: http://localhost:8081
```

### 修改FavoriteServiceImpl

```java
@Service
@RequiredArgsConstructor
public class FavoriteServiceImpl implements FavoriteService {

    private final FavoriteMapper favoriteMapper;
    private final RestTemplate restTemplate;

    @Value("${service.tool-service.base-url}")
    private String toolServiceBaseUrl;

    @Override
    public PageResult<ToolVO> getUserFavorites(Long userId, Long current, Long size) {
        // ... 前面代码不变

        // ✅ 使用配置的URL
        List<ToolVO> tools = new ArrayList<>();
        if (!toolIds.isEmpty()) {
            for (Long toolId : toolIds) {
                try {
                    String url = toolServiceBaseUrl + "/api/tools/" + toolId;

                    // 方式1: 直接获取ToolVO (如果tool-service直接返回对象)
                    ToolVO tool = restTemplate.getForObject(url, ToolVO.class);

                    // 方式2: 获取Result包装 (推荐)
                    /*
                    ParameterizedTypeReference<Result<ToolVO>> typeRef =
                        new ParameterizedTypeReference<Result<ToolVO>>() {};
                    ResponseEntity<Result<ToolVO>> response =
                        restTemplate.exchange(url, HttpMethod.GET, null, typeRef);

                    if (response.getBody() != null && response.getBody().isSuccess()) {
                        ToolVO tool = response.getBody().getData();
                        if (tool != null) {
                            tools.add(tool);
                        }
                    }
                    */

                    if (tool != null) {
                        tools.add(tool);
                    }
                } catch (Exception e) {
                    log.error("获取工具详情失败, toolId: {}", toolId, e);
                    // 继续处理下一个,不中断整个流程
                }
            }
        }

        // ... 后面代码不变
    }
}
```

---

## tool-service需要添加批量查询接口

### ToolController添加批量查询方法

**文件**: `tool-service/src/main/java/com/toolrecommend/tool/controller/ToolController.java`

```java
/**
 * 批量获取工具详情
 */
@GetMapping("/batch")
public Result<List<ToolVO>> getToolsByIds(@RequestParam("ids") List<Long> ids) {
    if (ids == null || ids.isEmpty()) {
        return Result.success(Collections.emptyList());
    }

    List<ToolVO> tools = toolService.getToolsByIds(ids);
    return Result.success(tools);
}
```

### ToolService接口

```java
/**
 * 批量获取工具详情
 */
List<ToolVO> getToolsByIds(List<Long> ids);
```

### ToolServiceImpl实现

```java
@Override
public List<ToolVO> getToolsByIds(List<Long> ids) {
    if (ids == null || ids.isEmpty()) {
        return Collections.emptyList();
    }

    List<Tool> tools = baseMapper.selectBatchIds(ids);
    return tools.stream()
            .map(this::convertToVO)
            .collect(Collectors.toList());
}
```

---

## 最佳实践总结

### 1. 服务间调用方式对比

| 方式 | 场景 | 优点 | 缺点 |
|------|------|------|------|
| **OpenFeign** | 推荐 | 声明式,易维护,支持降级 | 需要额外依赖 |
| **RestTemplate** | 临时 | 简单直接 | 代码冗余,难维护 |
| **WebClient** | 异步高并发 | 非阻塞,性能好 | 响应式编程学习曲线 |
| **Dubbo/gRPC** | 高性能RPC | 性能最好 | 侵入性强,复杂度高 |

### 2. 调用原则

1. **优先批量**: 批量调用 > 循环单次调用
2. **异常处理**: 必须有降级方案,不能让单个服务故障影响整体
3. **超时配置**: 合理设置连接和读取超时
4. **日志记录**: 记录调用失败原因,便于排查
5. **避免循环依赖**: 服务A调用B,B不能调用A

### 3. 性能优化

```java
// ❌ 不推荐: 循环调用
for (Long toolId : toolIds) {
    ToolVO tool = toolServiceClient.getToolById(toolId);  // N次网络调用
}

// ✅ 推荐: 批量调用
Result<List<ToolVO>> result = toolServiceClient.getToolsByIds(toolIds);  // 1次网络调用
```

### 4. 异常处理

```java
try {
    Result<ToolVO> result = toolServiceClient.getToolById(toolId);
    if (result != null && result.isSuccess()) {
        return result.getData();
    }
} catch (FeignException.NotFound e) {
    // 404: 工具不存在
    log.warn("工具不存在: {}", toolId);
} catch (FeignException.ServiceUnavailable e) {
    // 503: 服务不可用
    log.error("tool-service不可用");
} catch (Exception e) {
    // 其他异常
    log.error("调用失败", e);
}
```

---

## 配置示例

### development环境

```yaml
service:
  tool-service:
    url: http://localhost:8081
  review-service:
    url: http://localhost:8084
```

### production环境

```yaml
service:
  tool-service:
    url: http://tool-service:8081  # K8s Service名称
  review-service:
    url: http://review-service:8084
```

---

## 常见问题

### Q1: Feign调用返回null?
**A**: 检查返回类型是否匹配,tool-service是否返回`Result<T>`包装

### Q2: 超时异常?
**A**: 增加超时时间或优化tool-service性能

### Q3: 循环依赖?
**A**: 重新设计服务边界,避免双向调用

### Q4: 批量查询太慢?
**A**:
- 优化SQL查询
- 添加缓存(Redis)
- 使用异步调用

---

**版本**: v1.0
**作者**: AI Tool Recommend Team
**更新时间**: 2025-12-10
