# AI工具推荐系统 - 技术架构文档

## 文档信息
- **项目名称**：智能工具推荐平台
- **版本**：v1.0
- **创建日期**：2025-12-04
- **架构师**：[待填写]

---

## 一、架构概览

### 1.1 架构设计原则
- **高可用性**：系统可用性 >= 99.5%，支持故障自动恢复
- **高性能**：API响应 < 300ms，支持1000+并发用户
- **可扩展性**：微服务架构，支持水平扩展
- **安全性**：全链路加密，多层安全防护
- **可维护性**：代码规范，文档完善，日志完整

### 1.2 技术选型总览

| 层级 | 技术栈 | 选型理由 |
|------|--------|----------|
| **前端** | Vue 3 + TypeScript + UniApp | 一套代码多端运行，开发效率高 |
| **网关** | Spring Cloud Gateway | Spring生态，性能好，易集成 |
| **后端** | Spring Boot 3.2 + Java 17 | 成熟稳定，生态完善 |
| **数据库** | MySQL 8.0 | 关系型数据，事务支持强 |
| **缓存** | Redis 7 | 高性能KV存储，丰富数据结构 |
| **搜索** | Elasticsearch 8 | 全文检索，聚合分析强大 |
| **向量库** | Qdrant | 轻量易部署，性能优秀 |
| **消息队列** | Kafka | 高吞吐，持久化，支持流处理 |
| **AI服务** | Ollama + 通义千问 | 混合方案，平衡成本和质量 |
| **容器编排** | Kubernetes | 云原生标准，自动化运维 |
| **CI/CD** | Jenkins + Harbor + ArgoCD | 自动化构建部署 |
| **监控** | Prometheus + Grafana | 完善的监控和告警体系 |

---

## 二、整体架构设计

### 2.1 系统架构图

```
┌─────────────────────────────────────────────────────────────┐
│                        用户层                                 │
│  ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌──────────┐    │
│  │   Web    │  │   H5     │  │ 微信小程序│  │  管理后台 │    │
│  │  Vue3    │  │  UniApp  │  │  UniApp  │  │ Element+ │    │
│  └──────────┘  └──────────┘  └──────────┘  └──────────┘    │
└─────────────────────────────────────────────────────────────┘
                         ↓ HTTPS/WSS
┌─────────────────────────────────────────────────────────────┐
│                      CDN + 负载均衡                           │
│              Nginx / Cloudflare / 阿里云CDN                  │
└─────────────────────────────────────────────────────────────┘
                         ↓
┌─────────────────────────────────────────────────────────────┐
│                    API网关层 (K8s Ingress)                    │
│                 Spring Cloud Gateway                         │
│   ┌─────────────────────────────────────────────────┐       │
│   │ 统一鉴权 │ 限流 │ 路由 │ 熔断 │ 日志 │ 监控      │       │
│   └─────────────────────────────────────────────────┘       │
└─────────────────────────────────────────────────────────────┘
                         ↓
┌─────────────────────────────────────────────────────────────┐
│                     应用服务层 (K8s Pods)                     │
│                                                               │
│  ┌───────────────┐  ┌───────────────┐  ┌───────────────┐   │
│  │ tool-service  │  │ user-service  │  │ ai-service    │   │
│  │ 工具管理       │  │ 用户认证       │  │ AI推荐        │   │
│  │ 分类标签       │  │ 个人中心       │  │ 对话管理      │   │
│  │ 搜索排序       │  │ 权限管理       │  │ 向量检索      │   │
│  └───────────────┘  └───────────────┘  └───────────────┘   │
│                                                               │
│  ┌───────────────┐  ┌───────────────┐  ┌───────────────┐   │
│  │review-service │  │ admin-service │  │ notify-service│   │
│  │ 评分评论       │  │ 后台管理       │  │ 消息通知      │   │
│  │ 互动点赞       │  │ 数据统计       │  │ 邮件短信      │   │
│  └───────────────┘  └───────────────┘  └───────────────┘   │
└─────────────────────────────────────────────────────────────┘
                         ↓
┌─────────────────────────────────────────────────────────────┐
│                    中间件层 (K8s StatefulSet)                 │
│                                                               │
│  ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌──────────┐    │
│  │  Kafka   │  │  Redis   │  │Elastic   │  │  Qdrant  │    │
│  │  消息队列 │  │  缓存    │  │  Search  │  │  向量库   │    │
│  │          │  │          │  │  搜索    │  │          │    │
│  └──────────┘  └──────────┘  └──────────┘  └──────────┘    │
└─────────────────────────────────────────────────────────────┘
                         ↓
┌─────────────────────────────────────────────────────────────┐
│                      数据层 (K8s PV/PVC)                      │
│                                                               │
│  ┌──────────────┐          ┌──────────────┐                 │
│  │   MySQL      │          │   MinIO/OSS  │                 │
│  │   主从集群    │          │   对象存储    │                 │
│  │   读写分离    │          │   图片文件    │                 │
│  └──────────────┘          └──────────────┘                 │
└─────────────────────────────────────────────────────────────┘
                         ↓
┌─────────────────────────────────────────────────────────────┐
│                     AI服务层 (独立GPU节点)                     │
│                                                               │
│  ┌──────────────┐          ┌──────────────┐                 │
│  │   Ollama     │          │  Cloud AI    │                 │
│  │   本地模型    │          │  通义千问     │                 │
│  │   Qwen2.5    │          │  智谱GLM     │                 │
│  │   BGE向量    │          │  (备用)      │                 │
│  └──────────────┘          └──────────────┘                 │
└─────────────────────────────────────────────────────────────┘
```

### 2.2 数据流向图

```
用户请求流程：
1. 用户访问 → CDN/Nginx → K8s Ingress → Gateway
2. Gateway鉴权/限流 → 路由到对应微服务
3. 微服务处理 → 查询缓存(Redis) → 查询数据库(MySQL)
4. 返回结果 → 更新缓存 → 返回给用户

AI推荐流程：
1. 用户提问 → ai-service
2. 意图识别 → 实体提取
3. 查询复杂度评估 → 选择AI模型(Ollama/Cloud)
4. 向量检索(Qdrant) + 关键词搜索(ES)
5. 候选工具召回 → 排序算法
6. 生成推荐理由 → 返回结果
7. 记录对话历史 → Kafka异步处理

异步处理流程：
1. 用户操作(评论/收藏/浏览) → 发送Kafka消息
2. 消费者处理 → 更新统计数据
3. 更新热榜缓存 → 更新搜索索引
4. 记录用户行为 → 用于个性化推荐
```

---

## 三、微服务详细设计

### 3.1 tool-service（工具服务）

**职责**：
- 工具的CRUD操作
- 分类和标签管理
- 工具搜索和筛选
- 工具排行榜
- 工具推荐算法

**技术栈**：
- Spring Boot 3.2
- MyBatis Plus 3.5
- Redis（缓存热门工具）
- Elasticsearch（全文检索）
- Kafka（发送工具事件）

**核心接口**：
```java
// 工具控制器
@RestController
@RequestMapping("/api/tools")
public class ToolController {

    // 获取工具列表
    @GetMapping
    public Result<Page<ToolVO>> listTools(ToolQueryDTO query);

    // 获取工具详情
    @GetMapping("/{id}")
    public Result<ToolDetailVO> getToolDetail(@PathVariable Long id);

    // 搜索工具
    @GetMapping("/search")
    public Result<Page<ToolVO>> searchTools(SearchDTO search);

    // 获取热门工具
    @GetMapping("/hot")
    public Result<List<ToolVO>> getHotTools();

    // 获取新品工具
    @GetMapping("/new")
    public Result<List<ToolVO>> getNewTools();

    // 创建工具（管理员）
    @PostMapping
    @PreAuthorize("hasRole('ADMIN')")
    public Result<Long> createTool(@RequestBody ToolCreateDTO dto);

    // 更新工具
    @PutMapping("/{id}")
    @PreAuthorize("hasRole('ADMIN')")
    public Result<Void> updateTool(@PathVariable Long id,
                                    @RequestBody ToolUpdateDTO dto);

    // 删除工具
    @DeleteMapping("/{id}")
    @PreAuthorize("hasRole('ADMIN')")
    public Result<Void> deleteTool(@PathVariable Long id);
}
```

**数据库表**：
- tool（工具主表）
- category（分类表）
- tag（标签表）
- tool_tag（工具标签关联）
- tool_alternative（替代关系）
- tool_feature（工具特性）

**缓存策略**：
```java
// 缓存设计
public class ToolCacheService {

    // 工具详情缓存（1小时）
    @Cacheable(value = "tool:detail", key = "#id", ttl = 3600)
    public ToolDetailVO getToolDetail(Long id);

    // 热门工具缓存（10分钟）
    @Cacheable(value = "tool:hot", ttl = 600)
    public List<ToolVO> getHotTools();

    // 分类工具数量缓存（30分钟）
    @Cacheable(value = "category:count", key = "#categoryId", ttl = 1800)
    public Long getCategoryToolCount(Integer categoryId);

    // 缓存更新策略
    @CacheEvict(value = "tool:detail", key = "#id")
    public void evictToolCache(Long id);
}
```

**性能优化**：
- 工具列表使用分页查询，默认20条/页
- 热门工具使用Redis Sorted Set存储，按热度排序
- 工具详情使用缓存，减少数据库查询
- 搜索使用Elasticsearch，支持全文检索和聚合

---

### 3.2 user-service（用户服务）

**职责**：
- 用户注册和登录
- JWT令牌管理
- 用户信息管理
- 权限控制
- 用户行为记录

**技术栈**：
- Spring Boot 3.2 + Spring Security
- JWT（jsonwebtoken 0.12.0）
- Redis（存储token和用户会话）
- MySQL（用户数据持久化）

**核心接口**：
```java
@RestController
@RequestMapping("/api/users")
public class UserController {

    // 用户注册
    @PostMapping("/register")
    public Result<Void> register(@RequestBody UserRegisterDTO dto);

    // 用户登录
    @PostMapping("/login")
    public Result<LoginVO> login(@RequestBody UserLoginDTO dto);

    // 刷新token
    @PostMapping("/refresh")
    public Result<TokenVO> refreshToken(@RequestHeader String refreshToken);

    // 获取当前用户信息
    @GetMapping("/me")
    public Result<UserVO> getCurrentUser();

    // 更新用户信息
    @PutMapping("/me")
    public Result<Void> updateProfile(@RequestBody UserUpdateDTO dto);

    // 修改密码
    @PostMapping("/change-password")
    public Result<Void> changePassword(@RequestBody PasswordChangeDTO dto);

    // 收藏工具
    @PostMapping("/favorites/{toolId}")
    public Result<Void> addFavorite(@PathVariable Long toolId);

    // 取消收藏
    @DeleteMapping("/favorites/{toolId}")
    public Result<Void> removeFavorite(@PathVariable Long toolId);

    // 获取收藏列表
    @GetMapping("/favorites")
    public Result<List<ToolVO>> getFavorites();

    // 点赞工具
    @PostMapping("/upvotes/{toolId}")
    public Result<Void> upvoteTool(@PathVariable Long toolId);
}
```

**安全设计**：
```java
// JWT配置
@Configuration
public class JwtConfig {

    @Value("${jwt.secret}")
    private String secret;

    @Value("${jwt.access-token-validity:3600}") // 1小时
    private long accessTokenValidity;

    @Value("${jwt.refresh-token-validity:604800}") // 7天
    private long refreshTokenValidity;

    // 生成访问令牌
    public String generateAccessToken(Long userId) {
        return Jwts.builder()
            .setSubject(userId.toString())
            .setIssuedAt(new Date())
            .setExpiration(new Date(System.currentTimeMillis() +
                          accessTokenValidity * 1000))
            .signWith(SignatureAlgorithm.HS512, secret)
            .compact();
    }

    // 生成刷新令牌
    public String generateRefreshToken(Long userId) {
        String token = Jwts.builder()
            .setSubject(userId.toString())
            .setIssuedAt(new Date())
            .setExpiration(new Date(System.currentTimeMillis() +
                          refreshTokenValidity * 1000))
            .signWith(SignatureAlgorithm.HS512, secret)
            .compact();

        // 存储到Redis
        redisTemplate.opsForValue().set(
            "refresh_token:" + userId,
            token,
            refreshTokenValidity,
            TimeUnit.SECONDS
        );

        return token;
    }

    // 验证令牌
    public boolean validateToken(String token) {
        try {
            Jwts.parser()
                .setSigningKey(secret)
                .parseClaimsJws(token);
            return true;
        } catch (Exception e) {
            return false;
        }
    }
}

// 权限拦截器
@Component
public class JwtAuthenticationFilter extends OncePerRequestFilter {

    @Override
    protected void doFilterInternal(HttpServletRequest request,
                                   HttpServletResponse response,
                                   FilterChain filterChain) {
        String token = extractToken(request);

        if (token != null && jwtConfig.validateToken(token)) {
            Long userId = jwtConfig.getUserIdFromToken(token);
            // 设置Security Context
            Authentication auth = new UsernamePasswordAuthenticationToken(
                userId, null, getAuthorities(userId)
            );
            SecurityContextHolder.getContext().setAuthentication(auth);
        }

        filterChain.doFilter(request, response);
    }
}
```

**数据库表**：
- user（用户主表）
- user_action（用户行为表：浏览/收藏/点赞）
- user_role（用户角色表）

---

### 3.3 ai-service（AI推荐服务）

**职责**：
- AI对话管理
- 意图识别和实体提取
- 工具推荐算法
- 向量检索
- 推荐理由生成

**技术栈**：
- Spring Boot 3.2
- Spring AI（统一AI接口）
- Qdrant（向量数据库）
- Ollama（本地LLM）
- 通义千问API（云端LLM）
- Kafka（异步处理）

**核心接口**：
```java
@RestController
@RequestMapping("/api/ai")
public class AIController {

    // 开始对话
    @PostMapping("/chat")
    public Result<ChatResponseVO> chat(@RequestBody ChatRequestDTO dto);

    // 流式对话（SSE）
    @GetMapping("/chat/stream")
    public SseEmitter chatStream(@RequestParam String message,
                                 @RequestParam String sessionId);

    // 获取对话历史
    @GetMapping("/conversations")
    public Result<List<ConversationVO>> getConversations();

    // 获取对话详情
    @GetMapping("/conversations/{sessionId}")
    public Result<ConversationDetailVO> getConversationDetail(
        @PathVariable String sessionId);

    // 删除对话
    @DeleteMapping("/conversations/{sessionId}")
    public Result<Void> deleteConversation(@PathVariable String sessionId);

    // 反馈推荐结果
    @PostMapping("/feedback")
    public Result<Void> feedback(@RequestBody FeedbackDTO dto);
}
```

**AI推荐核心算法**：
```java
@Service
public class AIRecommendationService {

    @Autowired
    private OllamaService ollamaService;

    @Autowired
    private CloudAIService cloudAIService;

    @Autowired
    private VectorStoreService vectorStoreService;

    @Autowired
    private ToolRankingService rankingService;

    /**
     * 混合推荐算法
     */
    public ChatResponse recommend(String userMessage, String sessionId) {
        // 1. 提取意图和实体
        IntentEntity intent = extractIntent(userMessage);

        // 2. 判断查询复杂度
        int complexity = calculateComplexity(intent);

        // 3. 选择AI模型
        LLMService llmService = selectLLM(complexity);

        // 4. 向量检索 + 关键词搜索
        List<Tool> candidates = retrieveCandidates(intent);

        // 5. 多维度排序
        List<Tool> rankedTools = rankingService.rankTools(
            candidates,
            intent,
            getUserContext(sessionId)
        );

        // 6. 生成推荐理由
        ChatResponse response = llmService.generateResponse(
            userMessage,
            rankedTools.subList(0, Math.min(5, rankedTools.size()))
        );

        // 7. 保存对话历史
        saveConversation(sessionId, userMessage, response);

        // 8. 异步更新推荐效果
        kafkaTemplate.send("recommendation.events",
                          new RecommendationEvent(sessionId, response));

        return response;
    }

    /**
     * 意图识别
     */
    private IntentEntity extractIntent(String message) {
        String prompt = """
            分析用户意图，提取关键信息，返回JSON格式：
            {
              "intent": "FIND_TOOL|COMPARE_TOOLS|GET_ALTERNATIVE",
              "toolType": "工具类型",
              "features": ["功能1", "功能2"],
              "platform": ["Web", "iOS"],
              "budget": "免费|付费|具体金额",
              "scenario": "使用场景"
            }

            用户消息：%s
            """.formatted(message);

        // 使用快速模型提取（Ollama本地）
        String jsonResult = ollamaService.chat(prompt);
        return parseIntentEntity(jsonResult);
    }

    /**
     * 计算查询复杂度
     */
    private int calculateComplexity(IntentEntity intent) {
        int score = 0;

        // 意图复杂度
        if (intent.getIntent() == IntentType.COMPARE_TOOLS) {
            score += 3;
        }

        // 实体数量
        score += intent.getFeatures().size();

        // 需要推理
        if (intent.getBudget() != null && intent.getScenario() != null) {
            score += 2;
        }

        return score;
    }

    /**
     * 选择AI模型
     */
    private LLMService selectLLM(int complexity) {
        if (complexity < 3) {
            // 简单查询 -> Ollama本地
            return ollamaService;
        } else {
            // 复杂查询 -> 云端API
            return cloudAIService;
        }
    }

    /**
     * 候选工具召回
     */
    private List<Tool> retrieveCandidates(IntentEntity intent) {
        // 向量检索（语义匹配）
        List<Long> vectorResults = vectorStoreService.search(
            intent.toString(),
            50
        );

        // 关键词搜索（精确匹配）
        List<Long> keywordResults = elasticsearchService.search(
            intent.getToolType(),
            intent.getFeatures(),
            50
        );

        // 合并去重
        Set<Long> candidateIds = new HashSet<>();
        candidateIds.addAll(vectorResults);
        candidateIds.addAll(keywordResults);

        // 批量查询工具信息
        return toolService.batchGetTools(new ArrayList<>(candidateIds));
    }
}

/**
 * 工具排序算法
 */
@Service
public class ToolRankingService {

    public List<Tool> rankTools(List<Tool> candidates,
                                IntentEntity intent,
                                UserContext userContext) {
        return candidates.stream()
            .map(tool -> {
                double score = calculateScore(tool, intent, userContext);
                return new ScoredTool(tool, score);
            })
            .sorted(Comparator.comparingDouble(ScoredTool::getScore).reversed())
            .map(ScoredTool::getTool)
            .collect(Collectors.toList());
    }

    /**
     * 多维度评分算法
     * 总分 = 匹配度 × 0.3 + 质量分 × 0.25 + 热度分 × 0.25 +
     *       时新度 × 0.1 + 个性化 × 0.1
     */
    private double calculateScore(Tool tool,
                                  IntentEntity intent,
                                  UserContext userContext) {
        double matchScore = calculateMatchScore(tool, intent);
        double qualityScore = calculateQualityScore(tool);
        double popularityScore = calculatePopularityScore(tool);
        double freshnessScore = calculateFreshnessScore(tool);
        double personalScore = calculatePersonalScore(tool, userContext);

        return matchScore * 0.3 +
               qualityScore * 0.25 +
               popularityScore * 0.25 +
               freshnessScore * 0.1 +
               personalScore * 0.1;
    }

    // 匹配度：向量相似度 + 标签匹配 + 特性匹配
    private double calculateMatchScore(Tool tool, IntentEntity intent) {
        // 向量相似度
        double vectorSim = vectorStoreService.similarity(
            intent.toString(),
            tool.getEmbedding()
        );

        // 标签匹配（Jaccard相似度）
        double tagMatch = jaccardSimilarity(
            intent.getFeatures(),
            tool.getTags()
        );

        // 平台匹配
        double platformMatch = intent.getPlatform().stream()
            .anyMatch(tool.getPlatforms()::contains) ? 1.0 : 0.0;

        // 价格匹配
        double priceMatch = matchPrice(intent.getBudget(), tool.getPricing());

        return vectorSim * 0.4 + tagMatch * 0.3 +
               platformMatch * 0.2 + priceMatch * 0.1;
    }

    // 质量分：评分 + 评论数 + 信息完整度
    private double calculateQualityScore(Tool tool) {
        // 贝叶斯平均评分（避免少数评分偏差）
        double avgRating = tool.getAverageRating();
        int reviewCount = tool.getReviewCount();
        double bayesianAvg = (avgRating * reviewCount + 3.0 * 10) /
                            (reviewCount + 10);

        // 信息完整度
        double completeness = tool.getProfileCompleteness();

        return (bayesianAvg / 5.0) * 0.7 + completeness * 0.3;
    }

    // 热度分：浏览量 + 收藏数 + 增长率
    private double calculatePopularityScore(Tool tool) {
        double viewScore = Math.log10(tool.getViewCount() + 1) / 6.0;
        double favoriteScore = Math.log10(tool.getFavoriteCount() + 1) / 5.0;
        double growthRate = tool.getMonthlyGrowthRate();

        return viewScore * 0.4 + favoriteScore * 0.4 + growthRate * 0.2;
    }

    // 时新度：发布时间（新产品加权）
    private double calculateFreshnessScore(Tool tool) {
        long daysSinceLaunch = ChronoUnit.DAYS.between(
            tool.getLaunchDate(),
            LocalDate.now()
        );

        if (daysSinceLaunch < 30) {
            return 1.0;
        } else if (daysSinceLaunch < 90) {
            return 0.8;
        } else if (daysSinceLaunch < 180) {
            return 0.6;
        } else {
            return 0.4;
        }
    }

    // 个性化：用户历史偏好
    private double calculatePersonalScore(Tool tool, UserContext context) {
        if (context == null || context.getUserId() == null) {
            return 0.5; // 未登录用户默认分
        }

        // 用户收藏过的工具的特征
        Set<String> userPreferredTags = context.getPreferredTags();
        double tagMatch = jaccardSimilarity(userPreferredTags, tool.getTags());

        // 用户偏好的平台
        Set<String> userPreferredPlatforms = context.getPreferredPlatforms();
        double platformMatch = jaccardSimilarity(
            userPreferredPlatforms,
            tool.getPlatforms()
        );

        return tagMatch * 0.6 + platformMatch * 0.4;
    }
}
```

**向量数据库集成**：
```java
@Service
public class QdrantVectorService {

    @Autowired
    private QdrantClient qdrantClient;

    @Autowired
    private EmbeddingService embeddingService;

    // 索引工具
    public void indexTool(Tool tool) {
        String text = String.format("%s %s %s %s",
            tool.getName(),
            tool.getTagline(),
            tool.getDescription(),
            String.join(" ", tool.getTags())
        );

        float[] vector = embeddingService.embed(text);

        PointStruct point = PointStruct.newBuilder()
            .setId(PointId.newBuilder().setNum(tool.getId()).build())
            .setVectors(Vectors.newBuilder()
                .setVector(Vector.newBuilder()
                    .addAllData(Arrays.stream(vector).boxed().toList())
                    .build())
                .build())
            .putAllPayload(Map.of(
                "name", stringValue(tool.getName()),
                "category", stringValue(tool.getCategory()),
                "rating", doubleValue(tool.getAverageRating())
            ))
            .build();

        qdrantClient.upsert("tools", Collections.singletonList(point));
    }

    // 搜索相似工具
    public List<Long> search(String query, int limit) {
        float[] queryVector = embeddingService.embed(query);

        SearchPoints searchRequest = SearchPoints.newBuilder()
            .setCollectionName("tools")
            .addAllVector(Arrays.stream(queryVector).boxed().toList())
            .setLimit(limit)
            .setScoreThreshold(0.7f) // 相似度阈值
            .build();

        SearchResponse response = qdrantClient.search(searchRequest);

        return response.getResultList().stream()
            .map(scored -> scored.getId().getNum())
            .collect(Collectors.toList());
    }
}
```

---

### 3.4 review-service（评论服务）

**职责**：
- 评分和评论管理
- 评论审核
- 互动功能（点赞、回复）
- 评论统计

**核心接口**：
```java
@RestController
@RequestMapping("/api/reviews")
public class ReviewController {

    // 提交评论
    @PostMapping
    public Result<Long> createReview(@RequestBody ReviewCreateDTO dto);

    // 获取工具的评论列表
    @GetMapping("/tool/{toolId}")
    public Result<Page<ReviewVO>> getToolReviews(@PathVariable Long toolId,
                                                 @RequestParam String sort);

    // 点赞评论
    @PostMapping("/{reviewId}/like")
    public Result<Void> likeReview(@PathVariable Long reviewId);

    // 回复评论
    @PostMapping("/{reviewId}/reply")
    public Result<Long> replyReview(@PathVariable Long reviewId,
                                    @RequestBody ReplyDTO dto);

    // 举报评论
    @PostMapping("/{reviewId}/report")
    public Result<Void> reportReview(@PathVariable Long reviewId,
                                     @RequestBody ReportDTO dto);
}
```

---

### 3.5 admin-service（管理后台服务）

**职责**：
- 工具审核
- 用户管理
- 内容审核
- 数据统计
- 工单处理

**核心接口**：
```java
@RestController
@RequestMapping("/api/admin")
@PreAuthorize("hasRole('ADMIN')")
public class AdminController {

    // 待审核工具列表
    @GetMapping("/tools/pending")
    public Result<Page<ToolVO>> getPendingTools();

    // 审核工具
    @PostMapping("/tools/{id}/approve")
    public Result<Void> approveTool(@PathVariable Long id);

    // 驳回工具
    @PostMapping("/tools/{id}/reject")
    public Result<Void> rejectTool(@PathVariable Long id,
                                   @RequestBody RejectDTO dto);

    // 数据统计
    @GetMapping("/stats/overview")
    public Result<StatsOverviewVO> getStatsOverview();

    // 工单列表
    @GetMapping("/tickets")
    public Result<Page<TicketVO>> getTickets();

    // 处理工单
    @PostMapping("/tickets/{id}/handle")
    public Result<Void> handleTicket(@PathVariable Long id,
                                     @RequestBody TicketHandleDTO dto);
}
```

---

## 四、数据库设计

### 4.1 MySQL表结构
详见《数据库设计文档.md》

### 4.2 索引设计
```sql
-- 工具表索引
CREATE INDEX idx_tool_category ON tool(category_id, status);
CREATE INDEX idx_tool_launch_date ON tool(launch_date DESC);
CREATE INDEX idx_tool_rating ON tool(average_rating DESC);
CREATE FULLTEXT INDEX ft_tool_search ON tool(name, tagline, description);

-- 用户行为表索引
CREATE INDEX idx_action_user_tool ON user_action(user_id, tool_id, action_type);
CREATE INDEX idx_action_tool_time ON user_action(tool_id, created_at);

-- 评论表索引
CREATE INDEX idx_review_tool ON review(tool_id, status, created_at DESC);
CREATE INDEX idx_review_user ON review(user_id, created_at DESC);
```

### 4.3 分库分表策略
```java
// 使用ShardingSphere实现分库分表
@Configuration
public class ShardingConfig {

    @Bean
    public DataSource dataSource() {
        // 分片规则配置
        ShardingRuleConfiguration shardingRuleConfig =
            new ShardingRuleConfiguration();

        // user_action表按user_id分片（取模）
        TableRuleConfiguration userActionRule =
            new TableRuleConfiguration("user_action",
            "ds${0..1}.user_action_${0..15}");
        userActionRule.setTableShardingStrategyConfig(
            new StandardShardingStrategyConfiguration(
                "user_id",
                new UserActionShardingAlgorithm()
            )
        );

        shardingRuleConfig.getTableRuleConfigs().add(userActionRule);

        return ShardingDataSourceFactory.createDataSource(
            createDataSourceMap(),
            shardingRuleConfig,
            new Properties()
        );
    }
}
```

---

## 五、缓存架构设计

### 5.1 Redis缓存策略

```java
// 多级缓存设计
@Service
public class CacheService {

    @Autowired
    private RedisTemplate<String, Object> redisTemplate;

    @Autowired
    private CaffeineCache localCache; // 本地缓存

    /**
     * 三级缓存策略
     * L1: Caffeine本地缓存（小数据，高频访问）
     * L2: Redis缓存（分布式共享）
     * L3: MySQL数据库（持久化）
     */
    public Tool getTool(Long id) {
        // L1: 本地缓存
        Tool tool = localCache.get("tool:" + id);
        if (tool != null) {
            return tool;
        }

        // L2: Redis缓存
        tool = (Tool) redisTemplate.opsForValue().get("tool:" + id);
        if (tool != null) {
            localCache.put("tool:" + id, tool); // 回填L1
            return tool;
        }

        // L3: 数据库查询
        tool = toolMapper.selectById(id);
        if (tool != null) {
            // 回填L2和L1
            redisTemplate.opsForValue().set("tool:" + id, tool, 1, TimeUnit.HOURS);
            localCache.put("tool:" + id, tool);
        }

        return tool;
    }
}
```

### 5.2 缓存Key设计规范

```
命名规则：业务模块:数据类型:标识
过期时间：根据数据更新频率设置

示例：
tool:detail:123                 # 工具详情，1小时
tool:hot                         # 热门工具，10分钟
user:profile:456                 # 用户信息，30分钟
category:count:789               # 分类统计，30分钟
search:result:{hash}             # 搜索结果，5分钟
ai:conversation:{sessionId}      # 对话历史，1天
ranking:daily                    # 日榜，10分钟
ranking:weekly                   # 周榜，1小时
```

### 5.3 缓存更新策略

```java
// 缓存更新策略
@Service
public class CacheUpdateService {

    // 延迟双删策略
    public void updateTool(Tool tool) {
        // 1. 删除缓存
        deleteCache("tool:detail:" + tool.getId());

        // 2. 更新数据库
        toolMapper.updateById(tool);

        // 3. 延迟删除缓存（防止脏读）
        CompletableFuture.runAsync(() -> {
            try {
                Thread.sleep(500);
                deleteCache("tool:detail:" + tool.getId());
            } catch (InterruptedException e) {
                log.error("延迟删除缓存失败", e);
            }
        });
    }

    // 热点数据预热
    @Scheduled(cron = "0 0 2 * * ?") // 每天凌晨2点
    public void warmUpCache() {
        // 预热热门工具
        List<Tool> hotTools = toolMapper.selectHotTools(100);
        for (Tool tool : hotTools) {
            redisTemplate.opsForValue().set(
                "tool:detail:" + tool.getId(),
                tool,
                1,
                TimeUnit.HOURS
            );
        }

        // 预热排行榜
        List<Tool> ranking = calculateRanking();
        redisTemplate.opsForValue().set("ranking:daily", ranking,
                                       10, TimeUnit.MINUTES);
    }
}
```

---

## 六、消息队列架构

### 6.1 Kafka Topic设计

```yaml
Topic列表：
  tool.events:
    描述: 工具相关事件（创建、更新、删除）
    分区: 3
    副本: 2
    消费者: elasticsearch-sync, cache-update

  user.actions:
    描述: 用户行为事件（浏览、收藏、点赞）
    分区: 6
    副本: 2
    消费者: stats-service, recommendation-service

  review.events:
    描述: 评论事件（创建、点赞、举报）
    分区: 3
    副本: 2
    消费者: stats-service, notification-service

  recommendation.events:
    描述: AI推荐事件（对话、反馈）
    分区: 3
    副本: 2
    消费者: analytics-service

  notification.tasks:
    描述: 通知任务（邮件、短信、站内信）
    分区: 2
    副本: 2
    消费者: notification-service
```

### 6.2 消息生产者

```java
@Service
public class EventPublisher {

    @Autowired
    private KafkaTemplate<String, Object> kafkaTemplate;

    // 发布工具创建事件
    public void publishToolCreated(Tool tool) {
        ToolEvent event = ToolEvent.builder()
            .eventType(EventType.TOOL_CREATED)
            .toolId(tool.getId())
            .tool(tool)
            .timestamp(System.currentTimeMillis())
            .build();

        kafkaTemplate.send("tool.events", tool.getId().toString(), event);
    }

    // 发布用户行为事件
    public void publishUserAction(UserAction action) {
        UserActionEvent event = UserActionEvent.builder()
            .userId(action.getUserId())
            .toolId(action.getToolId())
            .actionType(action.getActionType())
            .timestamp(System.currentTimeMillis())
            .build();

        // 使用userId作为分区键，保证同一用户的消息有序
        kafkaTemplate.send("user.actions",
                          action.getUserId().toString(),
                          event);
    }
}
```

### 6.3 消息消费者

```java
// Elasticsearch同步消费者
@Service
public class ElasticsearchSyncConsumer {

    @KafkaListener(topics = "tool.events", groupId = "elasticsearch-sync")
    public void syncToElasticsearch(ToolEvent event) {
        switch (event.getEventType()) {
            case TOOL_CREATED:
            case TOOL_UPDATED:
                elasticsearchService.indexTool(event.getTool());
                break;
            case TOOL_DELETED:
                elasticsearchService.deleteTool(event.getToolId());
                break;
        }
    }
}

// 统计服务消费者
@Service
public class StatsConsumer {

    @KafkaListener(topics = "user.actions", groupId = "stats-service")
    public void updateStats(UserActionEvent event) {
        // 更新工具统计
        toolStatsService.incrementCount(
            event.getToolId(),
            event.getActionType()
        );

        // 更新用户行为记录
        userActionService.recordAction(event);

        // 更新热度排行榜
        rankingService.updateRanking(event.getToolId());
    }
}
```

---

## 七、API网关设计

### 7.1 Spring Cloud Gateway配置

```yaml
# gateway配置
spring:
  cloud:
    gateway:
      routes:
        # 工具服务路由
        - id: tool-service
          uri: lb://tool-service
          predicates:
            - Path=/api/tools/**
          filters:
            - name: RequestRateLimiter
              args:
                redis-rate-limiter.replenishRate: 100
                redis-rate-limiter.burstCapacity: 200

        # 用户服务路由
        - id: user-service
          uri: lb://user-service
          predicates:
            - Path=/api/users/**
          filters:
            - AuthenticationFilter

        # AI服务路由
        - id: ai-service
          uri: lb://ai-service
          predicates:
            - Path=/api/ai/**
          filters:
            - name: RequestRateLimiter
              args:
                redis-rate-limiter.replenishRate: 10  # AI限流更严格
                redis-rate-limiter.burstCapacity: 20

      default-filters:
        - AddResponseHeader=X-Response-Time, ${responseTime}
        - DedupeResponseHeader=Access-Control-Allow-Origin
```

### 7.2 网关过滤器

```java
// 全局鉴权过滤器
@Component
public class AuthenticationFilter implements GlobalFilter, Ordered {

    @Override
    public Mono<Void> filter(ServerWebExchange exchange,
                            GatewayFilterChain chain) {
        ServerHttpRequest request = exchange.getRequest();
        String path = request.getPath().toString();

        // 白名单路径不需要鉴权
        if (isWhitelist(path)) {
            return chain.filter(exchange);
        }

        // 提取token
        String token = extractToken(request);
        if (token == null || !jwtService.validateToken(token)) {
            return unauthorized(exchange);
        }

        // 验证通过，添加用户信息到header
        Long userId = jwtService.getUserIdFromToken(token);
        ServerHttpRequest mutatedRequest = request.mutate()
            .header("X-User-Id", userId.toString())
            .build();

        return chain.filter(
            exchange.mutate().request(mutatedRequest).build()
        );
    }

    @Override
    public int getOrder() {
        return -100; // 优先级最高
    }
}

// 限流过滤器（基于Redis）
@Component
public class RateLimiterFilter implements GlobalFilter, Ordered {

    @Autowired
    private RedisRateLimiter rateLimiter;

    @Override
    public Mono<Void> filter(ServerWebExchange exchange,
                            GatewayFilterChain chain) {
        String userId = exchange.getRequest()
            .getHeaders()
            .getFirst("X-User-Id");

        if (userId == null) {
            userId = exchange.getRequest()
                .getRemoteAddress()
                .getAddress()
                .getHostAddress();
        }

        return rateLimiter.isAllowed(userId, "api-rate-limit")
            .flatMap(response -> {
                if (!response.isAllowed()) {
                    return tooManyRequests(exchange);
                }
                return chain.filter(exchange);
            });
    }

    @Override
    public int getOrder() {
        return -90;
    }
}
```

---

## 八、监控和日志

### 8.1 监控指标

```yaml
监控体系：
  系统指标:
    - CPU使用率
    - 内存使用率
    - 磁盘IO
    - 网络流量

  应用指标:
    - QPS（每秒请求数）
    - 响应时间（P50/P95/P99）
    - 错误率
    - 接口调用量

  业务指标:
    - DAU/MAU
    - AI对话数
    - 工具浏览量
    - 用户注册数

  数据库指标:
    - 连接数
    - 慢查询数
    - QPS/TPS
    - 主从延迟

  缓存指标:
    - 命中率
    - 内存使用率
    - 连接数

  消息队列指标:
    - 消息积压数
    - 消费延迟
    - 吞吐量
```

### 8.2 日志规范

```java
// 日志配置（logback-spring.xml）
<configuration>
    <appender name="CONSOLE" class="ch.qos.logback.core.ConsoleAppender">
        <encoder>
            <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{50} - %msg%n</pattern>
        </encoder>
    </appender>

    <appender name="FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <file>logs/app.log</file>
        <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
            <fileNamePattern>logs/app-%d{yyyy-MM-dd}.%i.log</fileNamePattern>
            <maxHistory>30</maxHistory>
        </rollingPolicy>
        <encoder>
            <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{50} - %msg%n</pattern>
        </encoder>
    </appender>

    <!-- ELK日志收集 -->
    <appender name="LOGSTASH" class="net.logstash.logback.appender.LogstashTcpSocketAppender">
        <destination>logstash:5000</destination>
        <encoder class="net.logstash.logback.encoder.LogstashEncoder">
            <customFields>{"app":"tool-recommend"}</customFields>
        </encoder>
    </appender>

    <root level="INFO">
        <appender-ref ref="CONSOLE" />
        <appender-ref ref="FILE" />
        <appender-ref ref="LOGSTASH" />
    </root>
</configuration>

// 日志使用规范
@Slf4j
@Service
public class ToolService {

    public Tool getTool(Long id) {
        log.info("查询工具详情, toolId={}", id);

        try {
            Tool tool = toolMapper.selectById(id);
            if (tool == null) {
                log.warn("工具不存在, toolId={}", id);
                return null;
            }

            log.debug("查询成功, tool={}", tool);
            return tool;

        } catch (Exception e) {
            log.error("查询工具详情失败, toolId={}", id, e);
            throw new BusinessException("查询失败");
        }
    }
}
```

---

## 九、安全架构

### 9.1 安全防护措施

```java
// SQL注入防护（使用MyBatis预编译）
@Mapper
public interface ToolMapper {
    // 正确方式：使用#{}
    @Select("SELECT * FROM tool WHERE id = #{id}")
    Tool selectById(Long id);

    // 错误方式：使用${}，有SQL注入风险
    // @Select("SELECT * FROM tool WHERE id = ${id}")
}

// XSS防护（输入过滤）
@Component
public class XssFilter implements Filter {

    @Override
    public void doFilter(ServletRequest request,
                        ServletResponse response,
                        FilterChain chain) {
        HttpServletRequest req = (HttpServletRequest) request;
        XssHttpServletRequestWrapper wrapper =
            new XssHttpServletRequestWrapper(req);
        chain.doFilter(wrapper, response);
    }
}

public class XssHttpServletRequestWrapper
       extends HttpServletRequestWrapper {

    @Override
    public String getParameter(String name) {
        String value = super.getParameter(name);
        return value != null ? cleanXss(value) : null;
    }

    private String cleanXss(String value) {
        // 过滤<script>、<iframe>等危险标签
        value = value.replaceAll("<script>", "");
        value = value.replaceAll("</script>", "");
        value = value.replaceAll("<iframe>", "");
        // ... 更多过滤规则
        return value;
    }
}

// CSRF防护（Spring Security）
@Configuration
@EnableWebSecurity
public class SecurityConfig {

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) {
        http.csrf()
            .csrfTokenRepository(CookieCsrfTokenRepository.withHttpOnlyFalse())
            .ignoringAntMatchers("/api/public/**");
        return http.build();
    }
}
```

### 9.2 接口安全

```java
// API签名验证
@Component
public class ApiSignatureFilter implements Filter {

    @Override
    public void doFilter(ServletRequest request,
                        ServletResponse response,
                        FilterChain chain) {
        HttpServletRequest req = (HttpServletRequest) request;

        String timestamp = req.getHeader("X-Timestamp");
        String nonce = req.getHeader("X-Nonce");
        String signature = req.getHeader("X-Signature");

        // 验证时间戳（5分钟内有效）
        long requestTime = Long.parseLong(timestamp);
        if (System.currentTimeMillis() - requestTime > 300000) {
            throw new SecurityException("请求已过期");
        }

        // 验证签名
        String expectedSignature = calculateSignature(timestamp, nonce);
        if (!expectedSignature.equals(signature)) {
            throw new SecurityException("签名验证失败");
        }

        chain.doFilter(request, response);
    }

    private String calculateSignature(String timestamp, String nonce) {
        String data = timestamp + nonce + SECRET_KEY;
        return DigestUtils.md5Hex(data);
    }
}
```

---

## 十、性能优化

### 10.1 数据库优化

```sql
-- 慢查询优化
-- 优化前：全表扫描
SELECT * FROM tool WHERE category_id = 1 AND status = 1 ORDER BY created_at DESC LIMIT 20;

-- 优化后：使用复合索引
CREATE INDEX idx_category_status_created ON tool(category_id, status, created_at DESC);

-- 分页优化：避免深分页
-- 优化前
SELECT * FROM tool WHERE status = 1 ORDER BY id DESC LIMIT 10000, 20;

-- 优化后：使用游标
SELECT * FROM tool WHERE status = 1 AND id < #{lastId} ORDER BY id DESC LIMIT 20;
```

### 10.2 接口优化

```java
// 批量查询优化
@Service
public class ToolService {

    // 优化前：N+1查询问题
    public List<ToolVO> getToolsOld(List<Long> ids) {
        List<ToolVO> result = new ArrayList<>();
        for (Long id : ids) {
            Tool tool = toolMapper.selectById(id); // N次查询
            ToolVO vo = convertToVO(tool);
            result.add(vo);
        }
        return result;
    }

    // 优化后：批量查询
    public List<ToolVO> getTools(List<Long> ids) {
        List<Tool> tools = toolMapper.selectBatchIds(ids); // 1次查询
        return tools.stream()
            .map(this::convertToVO)
            .collect(Collectors.toList());
    }

    // 异步并行查询
    public ToolDetailVO getToolDetail(Long id) {
        CompletableFuture<Tool> toolFuture =
            CompletableFuture.supplyAsync(() -> toolMapper.selectById(id));

        CompletableFuture<List<Review>> reviewsFuture =
            CompletableFuture.supplyAsync(() -> reviewService.getToolReviews(id));

        CompletableFuture<List<Tool>> similarFuture =
            CompletableFuture.supplyAsync(() -> getSimilarTools(id));

        // 等待所有查询完成
        CompletableFuture.allOf(toolFuture, reviewsFuture, similarFuture).join();

        return ToolDetailVO.builder()
            .tool(toolFuture.get())
            .reviews(reviewsFuture.get())
            .similarTools(similarFuture.get())
            .build();
    }
}
```

---

## 十一、灾备和容错

### 11.1 数据备份策略

```bash
# MySQL自动备份脚本
#!/bin/bash
DATE=$(date +%Y%m%d_%H%M%S)
BACKUP_DIR="/backup/mysql"
DB_NAME="tool_recommend"

# 全量备份
mysqldump -u root -p${MYSQL_PASSWORD} \
  --single-transaction \
  --routines \
  --triggers \
  --databases ${DB_NAME} \
  | gzip > ${BACKUP_DIR}/full_backup_${DATE}.sql.gz

# 上传到OSS
ossutil cp ${BACKUP_DIR}/full_backup_${DATE}.sql.gz \
  oss://tool-recommend-backup/mysql/

# 保留最近7天的备份
find ${BACKUP_DIR} -name "full_backup_*.sql.gz" -mtime +7 -delete
```

### 11.2 限流降级

```java
// Sentinel限流配置
@Configuration
public class SentinelConfig {

    @PostConstruct
    public void initFlowRules() {
        List<FlowRule> rules = new ArrayList<>();

        // AI接口限流：10 QPS
        FlowRule aiRule = new FlowRule();
        aiRule.setResource("/api/ai/chat");
        aiRule.setGrade(RuleConstant.FLOW_GRADE_QPS);
        aiRule.setCount(10);
        rules.add(aiRule);

        // 搜索接口限流：100 QPS
        FlowRule searchRule = new FlowRule();
        searchRule.setResource("/api/tools/search");
        searchRule.setGrade(RuleConstant.FLOW_GRADE_QPS);
        searchRule.setCount(100);
        rules.add(searchRule);

        FlowRuleManager.loadRules(rules);
    }

    // 降级规则
    @PostConstruct
    public void initDegradeRules() {
        List<DegradeRule> rules = new ArrayList<>();

        // AI服务降级：错误率>50%时降级
        DegradeRule rule = new DegradeRule();
        rule.setResource("/api/ai/chat");
        rule.setGrade(RuleConstant.DEGRADE_GRADE_EXCEPTION_RATIO);
        rule.setCount(0.5);
        rule.setTimeWindow(10); // 降级时长10秒
        rules.add(rule);

        DegradeRuleManager.loadRules(rules);
    }
}

// 降级处理
@Service
public class AIRecommendationService {

    @SentinelResource(
        value = "/api/ai/chat",
        blockHandler = "handleBlock",
        fallback = "handleFallback"
    )
    public ChatResponse chat(String message) {
        // 正常逻辑
        return aiService.chat(message);
    }

    // 限流处理
    public ChatResponse handleBlock(String message, BlockException e) {
        return ChatResponse.builder()
            .message("系统繁忙，请稍后再试")
            .build();
    }

    // 降级处理
    public ChatResponse handleFallback(String message, Throwable e) {
        log.error("AI服务异常，降级处理", e);

        // 降级策略：使用关键词搜索代替AI推荐
        List<Tool> tools = toolService.searchByKeyword(message);

        return ChatResponse.builder()
            .message("为您找到以下工具：")
            .tools(tools)
            .build();
    }
}
```

---

## 十二、部署架构

详见《K8s部署文档.md》

---

**文档版本**：v1.0
**最后更新**：2025-12-04
**审核状态**：待评审
